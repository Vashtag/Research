<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sigmoid PU Calculator</title>
  <style>
    :root { font-family: Arial, sans-serif; }
    body { margin: 24px; color: #1f2937; background: #f8fafc; }
    h1 { margin-bottom: 8px; }
    .card { background: white; border-radius: 10px; padding: 16px; box-shadow: 0 1px 3px rgba(0,0,0,.1); margin-bottom: 16px; }
    .small { font-size: 12px; color: #6b7280; }
    .controls { margin: 10px 0; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    button { padding: 8px 10px; border: none; border-radius: 6px; cursor: pointer; color: #fff; background: #2563eb; }
    button:hover { background: #1d4ed8; }
    .btn-secondary { background: #4b5563; }
    .btn-secondary:hover { background: #374151; }
    .error { color: #b91c1c; font-weight: 600; min-height: 20px; }

    .grid-wrap { overflow: auto; border: 1px solid #d1d5db; border-radius: 8px; max-height: 430px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #d1d5db; padding: 0; }
    .input-grid th { background: #f3f4f6; position: sticky; top: 0; z-index: 2; }
    .input-grid input {
      width: 100%; border: none; padding: 7px; box-sizing: border-box;
      font-size: 13px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
    }
    .input-grid input:focus { outline: 2px solid #93c5fd; outline-offset: -2px; }
    .group-pd { background: #e0f2fe !important; }
    .group-dp { background: #dcfce7 !important; }
    .group-gauss { background: #fef3c7 !important; }
    .group-vsm { background: #ede9fe !important; }

    .result-table th, .result-table td { padding: 8px; text-align: right; }
    .result-table th:first-child, .result-table td:first-child { text-align: left; }
    .result-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(420px, 1fr)); gap: 12px; }
    .result-block { border: 1px solid #d1d5db; border-radius: 8px; overflow: hidden; }
    .result-block h4 { margin: 0; padding: 8px 10px; background: #f3f4f6; }
    .copy-area { width: 100%; min-height: 90px; box-sizing: border-box; border: none; border-top: 1px solid #d1d5db; padding: 8px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; }

    /* Tab navigation */
    .tab-bar { display: flex; gap: 0; margin-bottom: 16px; }
    .tab-btn { padding: 10px 20px; border: 1px solid #d1d5db; border-bottom: none; border-radius: 8px 8px 0 0; cursor: pointer; background: #e5e7eb; color: #374151; font-weight: 600; font-size: 14px; }
    .tab-btn.active { background: #fff; color: #2563eb; border-bottom: 2px solid #fff; margin-bottom: -1px; z-index: 1; }
    .tab-btn:hover:not(.active) { background: #f3f4f6; }
    .tab-panel { display: none; }
    .tab-panel.active { display: block; }

    /* Chart grid */
    .chart-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(460px, 1fr)); gap: 16px; }
    .chart-card { border: 1px solid #d1d5db; border-radius: 8px; overflow: hidden; background: #fff; }
    .chart-card h4 { margin: 0; padding: 8px 12px; background: #f3f4f6; font-size: 14px; }
    .chart-card canvas { display: block; width: 100%; }
  </style>
</head>
<body>
  <h1>Pre-VR Upright PU Calculator</h1>

  <div class="tab-bar">
    <button class="tab-btn active" data-tab="pu">PU Calculator</button>
    <button class="tab-btn" data-tab="gauss">Gaussian FMS Analysis</button>
    <button class="tab-btn" data-tab="vsm">Vector Sum Model</button>
  </div>

  <!-- ===== PU Calculator Tab ===== -->
  <div id="tab-pu" class="tab-panel active">
  <p class="small">Paste all 16 columns directly from Excel. Left block is p-d (x + 7 columns), right block is d-p (x + 7 columns).</p>

  <div class="card">
    <div class="controls">
      <button id="addRows" class="btn-secondary" type="button">Add 10 Rows</button>
      <button id="clearGrid" class="btn-secondary" type="button">Clear Grid</button>
      <button id="runCalc" type="button">Calculate PU</button>
    </div>

    <div class="grid-wrap">
      <table class="input-grid">
        <thead>
          <tr>
            <th class="group-pd"><input data-header="0" value="p-d_x"></th>
            <th class="group-pd"><input data-header="1" value="p-d_grey"></th>
            <th class="group-pd"><input data-header="2" value="p-d_room_0"></th>
            <th class="group-pd"><input data-header="3" value="p-d_room_60"></th>
            <th class="group-pd"><input data-header="4" value="p-d_room_120"></th>
            <th class="group-pd"><input data-header="5" value="p-d_room_180"></th>
            <th class="group-pd"><input data-header="6" value="p-d_room_240"></th>
            <th class="group-pd"><input data-header="7" value="p-d_room_300"></th>
            <th class="group-dp"><input data-header="8" value="d-p_x"></th>
            <th class="group-dp"><input data-header="9" value="d-p_grey"></th>
            <th class="group-dp"><input data-header="10" value="d-p_room_0"></th>
            <th class="group-dp"><input data-header="11" value="d-p_room_60"></th>
            <th class="group-dp"><input data-header="12" value="d-p_room_120"></th>
            <th class="group-dp"><input data-header="13" value="d-p_room_180"></th>
            <th class="group-dp"><input data-header="14" value="d-p_room_240"></th>
            <th class="group-dp"><input data-header="15" value="d-p_room_300"></th>
          </tr>
        </thead>
        <tbody id="gridBody"></tbody>
      </table>
    </div>

    <p id="message" class="error"></p>
  </div>

  <div class="card">
    <h3>Results (copy-friendly format)</h3>
    <div id="results">No results yet.</div>
    <p class="small">PU formulas used: <strong>b(PU) = (|b(p-d)| + |b(d-p)|)/2</strong>, <strong>x0(PU) = ((x0(p-d) + x0(d-p))/2) - 180</strong>.</p>
  </div>
  </div><!-- end tab-pu -->

  <!-- ===== Gaussian FMS Analysis Tab ===== -->
  <div id="tab-gauss" class="tab-panel">
    <p class="small">Enter each participant's x0 value (per background) and FMS score. One row per participant. The app will fit a 3-parameter Gaussian for each background.</p>

    <div class="card">
      <div class="controls">
        <button id="gaussAddRows" class="btn-secondary" type="button">Add 10 Rows</button>
        <button id="gaussClearGrid" class="btn-secondary" type="button">Clear Grid</button>
        <button id="gaussRun" type="button">Run Gaussian Fit</button>
      </div>

      <div class="grid-wrap">
        <table class="input-grid">
          <thead>
            <tr>
              <th class="group-gauss">FMS</th>
              <th class="group-gauss">x0 grey</th>
              <th class="group-gauss">x0 room_0</th>
              <th class="group-gauss">x0 room_60</th>
              <th class="group-gauss">x0 room_120</th>
              <th class="group-gauss">x0 room_180</th>
              <th class="group-gauss">x0 room_240</th>
              <th class="group-gauss">x0 room_300</th>
            </tr>
          </thead>
          <tbody id="gaussGridBody"></tbody>
        </table>
      </div>

      <p id="gaussMessage" class="error"></p>
    </div>

    <div class="card">
      <h3>Gaussian Fit Results</h3>
      <div id="gaussResults">No results yet.</div>
    </div>

    <div class="card">
      <h3>Figures</h3>
      <div id="gaussCharts" class="chart-grid">No figures yet.</div>
    </div>
  </div><!-- end tab-gauss -->

  <!-- ===== Vector Sum Model Tab ===== -->
  <div id="tab-vsm" class="tab-panel">
    <p class="small">Enter PU values (degrees) for each body tilt and visual background condition. Each row is one body tilt. The model fits vis1, vis2, vis3 (visual harmonic weights) and bod (body weight) with gravity fixed at 1.</p>

    <div class="card">
      <div class="controls">
        <button id="vsmAddRows" class="btn-secondary" type="button">Add 10 Rows</button>
        <button id="vsmClearGrid" class="btn-secondary" type="button">Clear Grid</button>
        <button id="vsmRun" type="button">Fit Vector Sum Model</button>
      </div>

      <div class="grid-wrap">
        <table class="input-grid">
          <thead>
            <tr>
              <th class="group-vsm">Tilt</th>
              <th class="group-vsm">PU grey</th>
              <th class="group-vsm">PU room_0</th>
              <th class="group-vsm">PU room_60</th>
              <th class="group-vsm">PU room_120</th>
              <th class="group-vsm">PU room_180</th>
              <th class="group-vsm">PU room_240</th>
              <th class="group-vsm">PU room_300</th>
            </tr>
          </thead>
          <tbody id="vsmGridBody"></tbody>
        </table>
      </div>

      <p id="vsmMessage" class="error"></p>
    </div>

    <div class="card">
      <h3>Vector Sum Model Results</h3>
      <div id="vsmResults">No results yet.</div>
    </div>

    <div class="card">
      <h3>Predicted vs Actual</h3>
      <div id="vsmCharts" class="chart-grid">No figures yet.</div>
    </div>
  </div><!-- end tab-vsm -->

  <script>
    const TOTAL_COLUMNS = 16;
    const DEFAULT_ROWS = 45;

    function createRow(rowIndex) {
      const tr = document.createElement('tr');
      for (let c = 0; c < TOTAL_COLUMNS; c += 1) {
        const td = document.createElement('td');
        const input = document.createElement('input');
        input.type = 'text';
        input.dataset.row = String(rowIndex);
        input.dataset.col = String(c);
        td.appendChild(input);
        tr.appendChild(td);
      }
      return tr;
    }

    function addRows(count) {
      const body = document.getElementById('gridBody');
      const start = body.children.length;
      for (let i = 0; i < count; i += 1) body.appendChild(createRow(start + i));
    }

    function clearGrid() {
      document.querySelectorAll('#gridBody input').forEach((input) => { input.value = ''; });
    }

    function parseNumber(value) {
      const cleaned = value.trim();
      if (!cleaned) return null;
      const n = Number(cleaned);
      return Number.isFinite(n) ? n : null;
    }

    function headerNames() {
      const headers = [];
      document.querySelectorAll('thead input[data-header]').forEach((input, idx) => {
        headers.push(input.value.trim() || `col_${idx + 1}`);
      });
      return headers;
    }

    function collectData() {
      const headers = headerNames();
      const rows = [...document.querySelectorAll('#gridBody tr')];

      const pdX = [];
      const dpX = [];
      const pdSeries = Array.from({ length: 7 }, () => []);
      const dpSeries = Array.from({ length: 7 }, () => []);

      rows.forEach((row) => {
        const cells = [...row.querySelectorAll('input')];
        if (cells.length < TOTAL_COLUMNS) return;

        const xPd = parseNumber(cells[0].value);
        if (xPd !== null) {
          pdX.push(xPd);
          for (let i = 0; i < 7; i += 1) pdSeries[i].push(parseNumber(cells[i + 1].value));
        }

        const xDp = parseNumber(cells[8].value);
        if (xDp !== null) {
          dpX.push(xDp);
          for (let i = 0; i < 7; i += 1) dpSeries[i].push(parseNumber(cells[i + 9].value));
        }
      });

      if (pdX.length === 0 && dpX.length === 0) throw new Error('No valid x values found in the p-d or d-p x columns.');

      return { headers, pdX, pdSeries, dpX, dpSeries };
    }

    function handleGridPaste(event) {
      const target = event.target;
      if (!(target instanceof HTMLInputElement) || !target.closest('#gridBody')) return;

      const pasted = event.clipboardData?.getData('text');
      if (!pasted) return;
      event.preventDefault();

      const rowStart = Number(target.dataset.row);
      const colStart = Number(target.dataset.col);
      const lines = pasted.replace(/\r/g, '').split('\n').filter((line) => line.length > 0);
      const matrix = lines.map((line) => line.split('\t'));

      const neededRows = rowStart + matrix.length;
      const currentRows = document.querySelectorAll('#gridBody tr').length;
      if (neededRows > currentRows) addRows(neededRows - currentRows + 5);

      matrix.forEach((cells, rOffset) => {
        const r = rowStart + rOffset;
        cells.forEach((value, cOffset) => {
          const c = colStart + cOffset;
          if (c >= TOTAL_COLUMNS) return;
          const cell = document.querySelector(`#gridBody input[data-row="${r}"][data-col="${c}"]`);
          if (cell) cell.value = value.trim();
        });
      });
    }

    function sigmoid(x, b, x0) {
      const z = -(x - x0) / b;
      if (z > 60) return 0;
      if (z < -60) return 1;
      return 1 / (1 + Math.exp(z));
    }

    function sse(data, b, x0) {
      let err = 0;
      for (const [x, y] of data) {
        const d = sigmoid(x, b, x0) - y;
        err += d * d;
      }
      return err;
    }

    function rSquared(data, b, x0) {
      const meanY = data.reduce((sum, [, y]) => sum + y, 0) / data.length;
      let ssRes = 0;
      let ssTot = 0;
      for (const [x, y] of data) {
        const pred = sigmoid(x, b, x0);
        ssRes += (y - pred) ** 2;
        ssTot += (y - meanY) ** 2;
      }
      if (ssTot === 0) return NaN;
      return 1 - (ssRes / ssTot);
    }

    function fitColumn(data, direction) {
      const xs = data.map(([x]) => x);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);

      let bestErr = Infinity;
      let bestB = direction === 'dp' ? 1 : -1;
      let bestX0 = 0;

      const bMin = direction === 'dp' ? 0.05 : -200;
      const bMax = direction === 'dp' ? 200 : 0.95;
      const x0Min = Math.floor(minX - 100);
      const x0Max = Math.ceil(maxX + 100);

      for (let b = bMin; b <= bMax; b += 0.5) {
        if (Math.abs(b) < 1e-9) continue;
        if (direction === 'pd' && !(b < 1)) continue;
        if (direction === 'dp' && !(b > 0)) continue;

        for (let x0 = x0Min; x0 <= x0Max; x0 += 1) {
          const err = sse(data, b, x0);
          if (err < bestErr) {
            bestErr = err;
            bestB = b;
            bestX0 = x0;
          }
        }
      }

      let stepB = 5;
      let stepX0 = 5;
      while (stepB > 1e-4) {
        let improved = false;
        for (const db of [0, -stepB, stepB]) {
          for (const dx of [0, -stepX0, stepX0]) {
            const candB = bestB + db;
            if (Math.abs(candB) < 1e-9) continue;
            if (direction === 'pd' && !(candB < 1)) continue;
            if (direction === 'dp' && !(candB > 0)) continue;
            const candX0 = bestX0 + dx;
            const err = sse(data, candB, candX0);
            if (err < bestErr) {
              bestErr = err;
              bestB = candB;
              bestX0 = candX0;
              improved = true;
            }
          }
        }
        if (!improved) {
          stepB /= 2;
          stepX0 /= 2;
        }
      }

      return { b: bestB, x0: bestX0, r2: rSquared(data, bestB, bestX0), sse: bestErr, n: data.length };
    }

    function buildCopyTable(title, labels, rowsByMetric) {
      const header = [''].concat(labels).join('\t');
      const lines = [title, header];
      rowsByMetric.forEach((metricRow) => {
        lines.push([metricRow.label].concat(metricRow.values).join('\t'));
      });
      return lines.join('\n');
    }

    function renderBlock(title, labels, rowsByMetric) {
      const thead = `<tr><th></th>${labels.map((l) => `<th>${l}</th>`).join('')}</tr>`;
      const tbody = rowsByMetric
        .map((metricRow) => `<tr><td>${metricRow.label}</td>${metricRow.values.map((v) => `<td>${v}</td>`).join('')}</tr>`)
        .join('');
      const copyText = buildCopyTable(title, labels, rowsByMetric)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

      return `
        <div class="result-block">
          <h4>${title}</h4>
          <table class="result-table">
            <thead>${thead}</thead>
            <tbody>${tbody}</tbody>
          </table>
          <textarea class="copy-area" readonly>${copyText}</textarea>
        </div>
      `;
    }

    function renderResults(rows) {
      const labels = rows.map((row) => row.name);

      const pdBlock = renderBlock('Pre-VR Upright p-d', labels, [
        { label: 'b(preVR)', values: rows.map((row) => row.pdB) },
        { label: 'x0(preVR)', values: rows.map((row) => row.pdX0) },
        { label: 'Rsq', values: rows.map((row) => row.pdR2) },
      ]);

      const dpBlock = renderBlock('Pre-VR Upright d-p', labels, [
        { label: 'b(preVR)', values: rows.map((row) => row.dpB) },
        { label: 'x0(preVR)', values: rows.map((row) => row.dpX0) },
        { label: 'Rsq', values: rows.map((row) => row.dpR2) },
      ]);

      const puBlock = renderBlock('Pre-VR Upright PU', labels, [
        { label: 'b(preVR)', values: rows.map((row) => row.puB) },
        { label: 'x0(preVR)', values: rows.map((row) => row.puX0) },
      ]);

      return `<div class="result-grid">${pdBlock}${dpBlock}${puBlock}</div>`;
    }

    function toFmt(v) {
      return Number.isFinite(v) ? v.toFixed(4) : 'NaN';
    }

    function runCalculation() {
      const msg = document.getElementById('message');
      const resultsDiv = document.getElementById('results');
      msg.textContent = '';

      try {
        const { headers, pdX, pdSeries, dpX, dpSeries } = collectData();
        const rows = [];

        for (let i = 0; i < 7; i += 1) {
          const pdPoints = [];
          for (let r = 0; r < pdX.length; r += 1) {
            const y = pdSeries[i][r];
            if (y !== null) pdPoints.push([pdX[r], y]);
          }

          const dpPoints = [];
          for (let r = 0; r < dpX.length; r += 1) {
            const y = dpSeries[i][r];
            if (y !== null) dpPoints.push([dpX[r], y]);
          }

          const pdFit = pdPoints.length >= 3 ? fitColumn(pdPoints, 'pd') : null;
          const dpFit = dpPoints.length >= 3 ? fitColumn(dpPoints, 'dp') : null;

          const puB = (pdFit && dpFit) ? (Math.abs(pdFit.b) + Math.abs(dpFit.b)) / 2 : NaN;
          const puX0 = (pdFit && dpFit) ? ((pdFit.x0 + dpFit.x0) / 2) - 180 : NaN;

          rows.push({
            name: headers[i + 1].replace(/^p-d_/, ''),
            pdB: toFmt(pdFit?.b),
            pdX0: toFmt(pdFit?.x0),
            pdR2: toFmt(pdFit?.r2),
            dpB: toFmt(dpFit?.b),
            dpX0: toFmt(dpFit?.x0),
            dpR2: toFmt(dpFit?.r2),
            puB: toFmt(puB),
            puX0: toFmt(puX0),
          });
        }

        resultsDiv.innerHTML = renderResults(rows);
      } catch (error) {
        resultsDiv.textContent = 'No results yet.';
        msg.textContent = error.message;
      }
    }

    addRows(DEFAULT_ROWS);
    document.getElementById('gridBody').addEventListener('paste', handleGridPaste);
    document.getElementById('addRows').addEventListener('click', () => addRows(10));
    document.getElementById('clearGrid').addEventListener('click', clearGrid);
    document.getElementById('runCalc').addEventListener('click', runCalculation);

    /* ========== Tab switching ========== */
    document.querySelectorAll('.tab-btn').forEach((btn) => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach((b) => b.classList.remove('active'));
        document.querySelectorAll('.tab-panel').forEach((p) => p.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
      });
    });

    /* ========== Gaussian FMS Analysis ========== */
    const GAUSS_COLS = 8; // FMS + 7 backgrounds
    const GAUSS_DEFAULT_ROWS = 30;
    const GAUSS_BG_NAMES = ['grey', 'room_0', 'room_60', 'room_120', 'room_180', 'room_240', 'room_300'];

    function gaussCreateRow(rowIndex) {
      const tr = document.createElement('tr');
      for (let c = 0; c < GAUSS_COLS; c++) {
        const td = document.createElement('td');
        const input = document.createElement('input');
        input.type = 'text';
        input.dataset.row = String(rowIndex);
        input.dataset.col = String(c);
        td.appendChild(input);
        tr.appendChild(td);
      }
      return tr;
    }

    function gaussAddRows(count) {
      const body = document.getElementById('gaussGridBody');
      const start = body.children.length;
      for (let i = 0; i < count; i++) body.appendChild(gaussCreateRow(start + i));
    }

    function gaussClearGrid() {
      document.querySelectorAll('#gaussGridBody input').forEach((input) => { input.value = ''; });
    }

    function gaussHandlePaste(event) {
      const target = event.target;
      if (!(target instanceof HTMLInputElement) || !target.closest('#gaussGridBody')) return;
      const pasted = event.clipboardData?.getData('text');
      if (!pasted) return;
      event.preventDefault();

      const rowStart = Number(target.dataset.row);
      const colStart = Number(target.dataset.col);
      const lines = pasted.replace(/\r/g, '').split('\n').filter((l) => l.length > 0);
      const matrix = lines.map((l) => l.split('\t'));

      const neededRows = rowStart + matrix.length;
      const currentRows = document.querySelectorAll('#gaussGridBody tr').length;
      if (neededRows > currentRows) gaussAddRows(neededRows - currentRows + 5);

      matrix.forEach((cells, rOff) => {
        cells.forEach((val, cOff) => {
          const c = colStart + cOff;
          if (c >= GAUSS_COLS) return;
          const cell = document.querySelector(`#gaussGridBody input[data-row="${rowStart + rOff}"][data-col="${c}"]`);
          if (cell) cell.value = val.trim();
        });
      });
    }

    /* Collect Gaussian data: returns { fms: number[], x0PerBg: number[][] } */
    function gaussCollectData() {
      const rows = [...document.querySelectorAll('#gaussGridBody tr')];
      const fms = [];
      const x0PerBg = Array.from({ length: 7 }, () => []);

      rows.forEach((row) => {
        const cells = [...row.querySelectorAll('input')];
        if (cells.length < GAUSS_COLS) return;
        const fmsVal = parseNumber(cells[0].value);
        if (fmsVal === null) return;

        // Need at least one x0 in the row
        let hasX0 = false;
        const x0Vals = [];
        for (let i = 0; i < 7; i++) {
          const v = parseNumber(cells[i + 1].value);
          x0Vals.push(v);
          if (v !== null) hasX0 = true;
        }
        if (!hasX0) return;

        fms.push(fmsVal);
        for (let i = 0; i < 7; i++) x0PerBg[i].push(x0Vals[i]);
      });

      if (fms.length < 3) throw new Error('Need at least 3 participants with valid FMS and x0 data.');
      return { fms, x0PerBg };
    }

    /* 3-parameter Gaussian: y = a * exp(-((x - mu)^2) / (2 * sigma^2)) */
    function gaussian(x, a, mu, sigma) {
      return a * Math.exp(-((x - mu) ** 2) / (2 * sigma * sigma));
    }

    function gaussSSE(pairs, a, mu, sigma) {
      let err = 0;
      for (const [x, y] of pairs) {
        const d = gaussian(x, a, mu, sigma) - y;
        err += d * d;
      }
      return err;
    }

    function gaussRSquared(pairs, a, mu, sigma) {
      const meanY = pairs.reduce((s, [, y]) => s + y, 0) / pairs.length;
      let ssRes = 0, ssTot = 0;
      for (const [x, y] of pairs) {
        ssRes += (y - gaussian(x, a, mu, sigma)) ** 2;
        ssTot += (y - meanY) ** 2;
      }
      return ssTot === 0 ? NaN : 1 - ssRes / ssTot;
    }

    function fitGaussian(pairs) {
      // pairs: [[x0, fms], ...]
      const xs = pairs.map(([x]) => x);
      const ys = pairs.map(([, y]) => y);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const maxY = Math.max(...ys);
      const meanX = xs.reduce((a, b) => a + b, 0) / xs.length;

      let bestErr = Infinity;
      let bestA = maxY, bestMu = meanX, bestSig = (maxX - minX) / 4;

      // Coarse grid search
      for (let a = maxY * 0.2; a <= maxY * 1.5; a += maxY * 0.1 || 0.5) {
        for (let mu = minX; mu <= maxX; mu += (maxX - minX) / 20 || 1) {
          for (let sig = (maxX - minX) * 0.05; sig <= (maxX - minX) * 1.5; sig += (maxX - minX) * 0.1 || 1) {
            if (sig < 0.01) continue;
            const err = gaussSSE(pairs, a, mu, sig);
            if (err < bestErr) {
              bestErr = err;
              bestA = a;
              bestMu = mu;
              bestSig = sig;
            }
          }
        }
      }

      // Refinement via hill-climbing
      let stepA = maxY * 0.1 || 1;
      let stepMu = (maxX - minX) * 0.1 || 1;
      let stepSig = (maxX - minX) * 0.1 || 1;

      while (stepA > 1e-4 && stepMu > 1e-4 && stepSig > 1e-4) {
        let improved = false;
        for (const da of [0, -stepA, stepA]) {
          for (const dm of [0, -stepMu, stepMu]) {
            for (const ds of [0, -stepSig, stepSig]) {
              const cA = bestA + da;
              const cMu = bestMu + dm;
              const cSig = bestSig + ds;
              if (cA < 0 || cSig < 0.01) continue;
              const err = gaussSSE(pairs, cA, cMu, cSig);
              if (err < bestErr) {
                bestErr = err;
                bestA = cA;
                bestMu = cMu;
                bestSig = cSig;
                improved = true;
              }
            }
          }
        }
        if (!improved) {
          stepA /= 2;
          stepMu /= 2;
          stepSig /= 2;
        }
      }

      return { a: bestA, mu: bestMu, sigma: bestSig, r2: gaussRSquared(pairs, bestA, bestMu, bestSig), sse: bestErr, n: pairs.length };
    }

    /* Draw a chart on a canvas element */
    function drawGaussChart(canvas, pairs, fit, title) {
      const ctx = canvas.getContext('2d');
      const W = canvas.width;
      const H = canvas.height;
      const pad = { top: 30, right: 20, bottom: 50, left: 60 };
      const plotW = W - pad.left - pad.right;
      const plotH = H - pad.top - pad.bottom;

      ctx.clearRect(0, 0, W, H);

      // Data ranges
      const xs = pairs.map(([x]) => x);
      const ys = pairs.map(([, y]) => y);
      const xMin = Math.min(...xs) - Math.abs(Math.min(...xs)) * 0.1 - 5;
      const xMax = Math.max(...xs) + Math.abs(Math.max(...xs)) * 0.1 + 5;

      // Compute Gaussian curve to find actual y-range
      const curvePts = [];
      for (let i = 0; i <= 200; i++) {
        const x = xMin + (xMax - xMin) * (i / 200);
        curvePts.push([x, gaussian(x, fit.a, fit.mu, fit.sigma)]);
      }
      const allY = ys.concat(curvePts.map(([, y]) => y));
      const yMin = Math.min(0, Math.min(...allY) - 1);
      const yMax = Math.max(...allY) * 1.15;

      function toCanvasX(x) { return pad.left + ((x - xMin) / (xMax - xMin)) * plotW; }
      function toCanvasY(y) { return pad.top + plotH - ((y - yMin) / (yMax - yMin)) * plotH; }

      // Background
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, W, H);

      // Grid lines
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;
      const yTicks = 6;
      for (let i = 0; i <= yTicks; i++) {
        const y = yMin + (yMax - yMin) * (i / yTicks);
        const cy = toCanvasY(y);
        ctx.beginPath(); ctx.moveTo(pad.left, cy); ctx.lineTo(W - pad.right, cy); ctx.stroke();
      }

      // Axes
      ctx.strokeStyle = '#374151';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(pad.left, pad.top);
      ctx.lineTo(pad.left, pad.top + plotH);
      ctx.lineTo(W - pad.right, pad.top + plotH);
      ctx.stroke();

      // Axis labels
      ctx.fillStyle = '#374151';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';

      // X-axis ticks
      const xTicks = 6;
      for (let i = 0; i <= xTicks; i++) {
        const x = xMin + (xMax - xMin) * (i / xTicks);
        const cx = toCanvasX(x);
        ctx.beginPath(); ctx.moveTo(cx, pad.top + plotH); ctx.lineTo(cx, pad.top + plotH + 5); ctx.stroke();
        ctx.fillText(x.toFixed(1), cx, pad.top + plotH + 18);
      }

      // Y-axis ticks
      ctx.textAlign = 'right';
      for (let i = 0; i <= yTicks; i++) {
        const y = yMin + (yMax - yMin) * (i / yTicks);
        const cy = toCanvasY(y);
        ctx.fillText(y.toFixed(1), pad.left - 8, cy + 4);
      }

      // Axis titles
      ctx.save();
      ctx.font = '13px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('x0', pad.left + plotW / 2, H - 5);
      ctx.save();
      ctx.translate(15, pad.top + plotH / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('FMS', 0, 0);
      ctx.restore();
      ctx.restore();

      // Gaussian curve
      ctx.strokeStyle = '#dc2626';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      curvePts.forEach(([x, y], i) => {
        const cx = toCanvasX(x);
        const cy = toCanvasY(y);
        if (i === 0) ctx.moveTo(cx, cy);
        else ctx.lineTo(cx, cy);
      });
      ctx.stroke();

      // Data points
      ctx.fillStyle = '#2563eb';
      pairs.forEach(([x, y]) => {
        const cx = toCanvasX(x);
        const cy = toCanvasY(y);
        ctx.beginPath();
        ctx.arc(cx, cy, 5, 0, Math.PI * 2);
        ctx.fill();
      });

      // Title
      ctx.fillStyle = '#111827';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(title, W / 2, 18);

      // Fit info
      ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, monospace';
      ctx.fillStyle = '#6b7280';
      ctx.textAlign = 'left';
      ctx.fillText(`a=${fit.a.toFixed(2)}  mu=${fit.mu.toFixed(2)}  sigma=${fit.sigma.toFixed(2)}  R²=${fit.r2.toFixed(4)}`, pad.left + 5, pad.top + 15);
    }

    function runGaussianAnalysis() {
      const msg = document.getElementById('gaussMessage');
      const resultsDiv = document.getElementById('gaussResults');
      const chartsDiv = document.getElementById('gaussCharts');
      msg.textContent = '';

      try {
        const { fms, x0PerBg } = gaussCollectData();
        const fits = [];
        let resultsHTML = '';
        let chartsHTML = '';

        for (let i = 0; i < 7; i++) {
          const pairs = [];
          for (let j = 0; j < fms.length; j++) {
            if (x0PerBg[i][j] !== null) pairs.push([x0PerBg[i][j], fms[j]]);
          }

          if (pairs.length < 3) {
            fits.push(null);
            continue;
          }

          const fit = fitGaussian(pairs);
          fits.push({ ...fit, pairs });
          chartsHTML += `<div class="chart-card"><h4>${GAUSS_BG_NAMES[i]}</h4><canvas id="gaussCanvas_${i}" width="520" height="380"></canvas></div>`;
        }

        // Results table
        const labels = GAUSS_BG_NAMES.filter((_, i) => fits[i] !== null);
        const validFits = fits.filter((f) => f !== null);
        resultsHTML = renderBlock('Gaussian Fit Parameters', labels, [
          { label: 'a', values: validFits.map((f) => f.a.toFixed(4)) },
          { label: 'mu', values: validFits.map((f) => f.mu.toFixed(4)) },
          { label: 'sigma', values: validFits.map((f) => f.sigma.toFixed(4)) },
          { label: 'R²', values: validFits.map((f) => f.r2.toFixed(4)) },
          { label: 'n', values: validFits.map((f) => String(f.n)) },
        ]);

        resultsDiv.innerHTML = resultsHTML;
        chartsDiv.innerHTML = chartsHTML || 'No backgrounds with enough data.';

        // Draw charts after DOM update
        for (let i = 0; i < 7; i++) {
          if (!fits[i]) continue;
          const canvas = document.getElementById(`gaussCanvas_${i}`);
          if (canvas) drawGaussChart(canvas, fits[i].pairs, fits[i], GAUSS_BG_NAMES[i]);
        }
      } catch (error) {
        resultsDiv.textContent = 'No results yet.';
        chartsDiv.textContent = 'No figures yet.';
        msg.textContent = error.message;
      }
    }

    gaussAddRows(GAUSS_DEFAULT_ROWS);
    document.getElementById('gaussGridBody').addEventListener('paste', gaussHandlePaste);
    document.getElementById('gaussAddRows').addEventListener('click', () => gaussAddRows(10));
    document.getElementById('gaussClearGrid').addEventListener('click', gaussClearGrid);
    document.getElementById('gaussRun').addEventListener('click', runGaussianAnalysis);

    /* ========== Vector Sum Model ========== */
    const VSM_COLS = 8; // tilt + 7 backgrounds
    const VSM_DEFAULT_ROWS = 20;
    const VSM_VIS_ORIENTATIONS = [null, 0, 60, 120, 180, 240, 300]; // null = grey (no visual)
    const VSM_BG_NAMES = ['grey', 'room_0', 'room_60', 'room_120', 'room_180', 'room_240', 'room_300'];
    const DEG2RAD = Math.PI / 180;
    const RAD2DEG = 180 / Math.PI;

    function vsmCreateRow(rowIndex) {
      const tr = document.createElement('tr');
      for (let c = 0; c < VSM_COLS; c++) {
        const td = document.createElement('td');
        const input = document.createElement('input');
        input.type = 'text';
        input.dataset.row = String(rowIndex);
        input.dataset.col = String(c);
        td.appendChild(input);
        tr.appendChild(td);
      }
      return tr;
    }

    function vsmAddRows(count) {
      const body = document.getElementById('vsmGridBody');
      const start = body.children.length;
      for (let i = 0; i < count; i++) body.appendChild(vsmCreateRow(start + i));
    }

    function vsmClearGrid() {
      document.querySelectorAll('#vsmGridBody input').forEach((input) => { input.value = ''; });
    }

    function vsmHandlePaste(event) {
      const target = event.target;
      if (!(target instanceof HTMLInputElement) || !target.closest('#vsmGridBody')) return;
      const pasted = event.clipboardData?.getData('text');
      if (!pasted) return;
      event.preventDefault();

      const rowStart = Number(target.dataset.row);
      const colStart = Number(target.dataset.col);
      const lines = pasted.replace(/\r/g, '').split('\n').filter((l) => l.length > 0);
      const matrix = lines.map((l) => l.split('\t'));

      const neededRows = rowStart + matrix.length;
      const currentRows = document.querySelectorAll('#vsmGridBody tr').length;
      if (neededRows > currentRows) vsmAddRows(neededRows - currentRows + 5);

      matrix.forEach((cells, rOff) => {
        cells.forEach((val, cOff) => {
          const c = colStart + cOff;
          if (c >= VSM_COLS) return;
          const cell = document.querySelector(`#vsmGridBody input[data-row="${rowStart + rOff}"][data-col="${c}"]`);
          if (cell) cell.value = val.trim();
        });
      });
    }

    function vsmCollectData() {
      const rows = [...document.querySelectorAll('#vsmGridBody tr')];
      const dataPoints = []; // [{tilt, visOrientation (null for grey), actualPU}]

      rows.forEach((row) => {
        const cells = [...row.querySelectorAll('input')];
        if (cells.length < VSM_COLS) return;
        const tilt = parseNumber(cells[0].value);
        if (tilt === null) return;

        for (let i = 0; i < 7; i++) {
          const pu = parseNumber(cells[i + 1].value);
          if (pu === null) continue;
          dataPoints.push({ tilt, visIdx: i, visOrientation: VSM_VIS_ORIENTATIONS[i], actualPU: pu });
        }
      });

      if (dataPoints.length < 4) throw new Error('Need at least 4 valid PU data points to fit 4 parameters.');
      return dataPoints;
    }

    /* Predict PU using vector sum model */
    function vsmPredict(tiltDeg, visDeg, vis1, vis2, vis3, bod) {
      const g = 1;
      const tilt = tiltDeg * DEG2RAD;
      let vx = 0, vy = 0;

      if (visDeg !== null) {
        const v = visDeg * DEG2RAD;
        vy = vis1 * Math.cos(v) + vis2 * Math.cos(2 * v) + vis3 * Math.cos(4 * v);
        vx = vis1 * Math.sin(v) + vis2 * Math.sin(2 * v) + vis3 * Math.sin(4 * v);
      }

      const y = bod + vy + g * Math.cos(tilt);
      const x = vx + g * Math.sin(tilt);
      return Math.atan2(x, y) * RAD2DEG;
    }

    /* Angular difference handling wrapping */
    function angleDiff(a, b) {
      let d = a - b;
      while (d > 180) d -= 360;
      while (d < -180) d += 360;
      return d;
    }

    /* SSE for vector sum model */
    function vsmSSE(dataPoints, vis1, vis2, vis3, bod) {
      let err = 0;
      for (const dp of dataPoints) {
        const pred = vsmPredict(dp.tilt, dp.visOrientation, vis1, vis2, vis3, bod);
        const d = angleDiff(pred, dp.actualPU);
        err += d * d;
      }
      return err;
    }

    /* R² for vector sum model */
    function vsmRSquared(dataPoints, vis1, vis2, vis3, bod) {
      const meanPU = dataPoints.reduce((s, dp) => s + dp.actualPU, 0) / dataPoints.length;
      let ssRes = 0, ssTot = 0;
      for (const dp of dataPoints) {
        const pred = vsmPredict(dp.tilt, dp.visOrientation, vis1, vis2, vis3, bod);
        ssRes += angleDiff(pred, dp.actualPU) ** 2;
        ssTot += angleDiff(dp.actualPU, meanPU) ** 2;
      }
      return ssTot === 0 ? NaN : 1 - ssRes / ssTot;
    }

    /* Fit the vector sum model using coarse grid search + hill climbing */
    function fitVectorSum(dataPoints) {
      let bestErr = Infinity;
      let bestVis1 = 0, bestVis2 = 0, bestVis3 = 0, bestBod = 1;

      // Coarse grid search
      for (let vis1 = -1.5; vis1 <= 1.5; vis1 += 0.15) {
        for (let vis2 = -0.8; vis2 <= 0.8; vis2 += 0.2) {
          for (let vis3 = -0.5; vis3 <= 0.5; vis3 += 0.2) {
            for (let bod = -1; bod <= 4; bod += 0.25) {
              const err = vsmSSE(dataPoints, vis1, vis2, vis3, bod);
              if (err < bestErr) {
                bestErr = err;
                bestVis1 = vis1;
                bestVis2 = vis2;
                bestVis3 = vis3;
                bestBod = bod;
              }
            }
          }
        }
      }

      // Hill-climbing refinement
      let step = 0.1;
      while (step > 1e-5) {
        let improved = false;
        for (const d1 of [0, -step, step]) {
          for (const d2 of [0, -step, step]) {
            for (const d3 of [0, -step, step]) {
              for (const db of [0, -step, step]) {
                if (d1 === 0 && d2 === 0 && d3 === 0 && db === 0) continue;
                const cV1 = bestVis1 + d1;
                const cV2 = bestVis2 + d2;
                const cV3 = bestVis3 + d3;
                const cB = bestBod + db;
                const err = vsmSSE(dataPoints, cV1, cV2, cV3, cB);
                if (err < bestErr) {
                  bestErr = err;
                  bestVis1 = cV1;
                  bestVis2 = cV2;
                  bestVis3 = cV3;
                  bestBod = cB;
                  improved = true;
                }
              }
            }
          }
        }
        if (!improved) step /= 2;
      }

      const r2 = vsmRSquared(dataPoints, bestVis1, bestVis2, bestVis3, bestBod);
      return { vis1: bestVis1, vis2: bestVis2, vis3: bestVis3, bod: bestBod, r2, sse: bestErr, n: dataPoints.length };
    }

    /* Draw predicted vs actual scatter plot */
    function drawVsmChart(canvas, dataPoints, fit) {
      const ctx = canvas.getContext('2d');
      const W = canvas.width;
      const H = canvas.height;
      const pad = { top: 30, right: 20, bottom: 50, left: 60 };
      const plotW = W - pad.left - pad.right;
      const plotH = H - pad.top - pad.bottom;

      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, W, H);

      const actuals = dataPoints.map((dp) => dp.actualPU);
      const predicteds = dataPoints.map((dp) => vsmPredict(dp.tilt, dp.visOrientation, fit.vis1, fit.vis2, fit.vis3, fit.bod));
      const all = actuals.concat(predicteds);
      const dMin = Math.min(...all) - 5;
      const dMax = Math.max(...all) + 5;

      function toX(v) { return pad.left + ((v - dMin) / (dMax - dMin)) * plotW; }
      function toY(v) { return pad.top + plotH - ((v - dMin) / (dMax - dMin)) * plotH; }

      // Grid lines
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;
      const ticks = 6;
      for (let i = 0; i <= ticks; i++) {
        const v = dMin + (dMax - dMin) * (i / ticks);
        ctx.beginPath(); ctx.moveTo(pad.left, toY(v)); ctx.lineTo(W - pad.right, toY(v)); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(toX(v), pad.top); ctx.lineTo(toX(v), pad.top + plotH); ctx.stroke();
      }

      // Axes
      ctx.strokeStyle = '#374151';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(pad.left, pad.top);
      ctx.lineTo(pad.left, pad.top + plotH);
      ctx.lineTo(W - pad.right, pad.top + plotH);
      ctx.stroke();

      // Identity line (perfect fit)
      ctx.strokeStyle = '#9ca3af';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(toX(dMin), toY(dMin));
      ctx.lineTo(toX(dMax), toY(dMax));
      ctx.stroke();
      ctx.setLineDash([]);

      // Axis labels
      ctx.fillStyle = '#374151';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      for (let i = 0; i <= ticks; i++) {
        const v = dMin + (dMax - dMin) * (i / ticks);
        ctx.fillText(v.toFixed(1), toX(v), pad.top + plotH + 18);
      }
      ctx.textAlign = 'right';
      for (let i = 0; i <= ticks; i++) {
        const v = dMin + (dMax - dMin) * (i / ticks);
        ctx.fillText(v.toFixed(1), pad.left - 8, toY(v) + 4);
      }

      // Axis titles
      ctx.font = '13px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Actual PU (°)', pad.left + plotW / 2, H - 5);
      ctx.save();
      ctx.translate(15, pad.top + plotH / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Predicted PU (°)', 0, 0);
      ctx.restore();

      // Color per background
      const bgColors = ['#6b7280', '#2563eb', '#dc2626', '#059669', '#d97706', '#7c3aed', '#db2777'];

      // Data points
      dataPoints.forEach((dp, i) => {
        const actual = dp.actualPU;
        const pred = predicteds[i];
        ctx.fillStyle = bgColors[dp.visIdx];
        ctx.beginPath();
        ctx.arc(toX(actual), toY(pred), 5, 0, Math.PI * 2);
        ctx.fill();
      });

      // Title
      ctx.fillStyle = '#111827';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Predicted vs Actual PU', W / 2, 18);

      // Fit info
      ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, monospace';
      ctx.fillStyle = '#6b7280';
      ctx.textAlign = 'left';
      ctx.fillText(`R²=${fit.r2.toFixed(4)}  vis1=${fit.vis1.toFixed(4)}  vis2=${fit.vis2.toFixed(4)}  vis3=${fit.vis3.toFixed(4)}  bod=${fit.bod.toFixed(4)}`, pad.left + 5, pad.top + 15);

      // Legend
      const legendY = pad.top + 30;
      VSM_BG_NAMES.forEach((name, i) => {
        ctx.fillStyle = bgColors[i];
        ctx.beginPath();
        ctx.arc(pad.left + 12, legendY + i * 16, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#374151';
        ctx.font = '11px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(name, pad.left + 22, legendY + i * 16 + 4);
      });
    }

    function runVectorSumModel() {
      const msg = document.getElementById('vsmMessage');
      const resultsDiv = document.getElementById('vsmResults');
      const chartsDiv = document.getElementById('vsmCharts');
      msg.textContent = '';

      try {
        const dataPoints = vsmCollectData();
        const fit = fitVectorSum(dataPoints);

        // Build results table: parameters
        const paramsHTML = renderBlock('Fitted Parameters (g = 1.0 fixed)', ['Value'], [
          { label: 'vis1 (1st harmonic)', values: [fit.vis1.toFixed(6)] },
          { label: 'vis2 (2nd harmonic)', values: [fit.vis2.toFixed(6)] },
          { label: 'vis3 (4th harmonic)', values: [fit.vis3.toFixed(6)] },
          { label: 'bod (body weight)', values: [fit.bod.toFixed(6)] },
          { label: 'R²', values: [fit.r2.toFixed(6)] },
          { label: 'SSE', values: [fit.sse.toFixed(6)] },
          { label: 'n', values: [String(fit.n)] },
        ]);

        // Build predicted vs actual table grouped by tilt
        const tilts = [...new Set(dataPoints.map((dp) => dp.tilt))].sort((a, b) => a - b);
        const predRows = [];
        for (const tilt of tilts) {
          const tiltPts = dataPoints.filter((dp) => dp.tilt === tilt);
          const actualVals = [];
          const predVals = [];
          const bgLabels = [];
          for (const dp of tiltPts) {
            const pred = vsmPredict(dp.tilt, dp.visOrientation, fit.vis1, fit.vis2, fit.vis3, fit.bod);
            bgLabels.push(VSM_BG_NAMES[dp.visIdx]);
            actualVals.push(dp.actualPU.toFixed(2));
            predVals.push(pred.toFixed(2));
          }
          predRows.push({ tilt, bgLabels, actualVals, predVals });
        }

        // Render comparison table
        let compHTML = '<div class="result-block"><h4>Predicted vs Actual PU (°)</h4><table class="result-table"><thead><tr><th>Tilt</th><th>Background</th><th>Actual</th><th>Predicted</th><th>Error</th></tr></thead><tbody>';
        const copyLines = ['Tilt\tBackground\tActual\tPredicted\tError'];
        for (const pr of predRows) {
          for (let i = 0; i < pr.bgLabels.length; i++) {
            const err = (parseFloat(pr.predVals[i]) - parseFloat(pr.actualVals[i])).toFixed(2);
            compHTML += `<tr><td>${pr.tilt}</td><td>${pr.bgLabels[i]}</td><td>${pr.actualVals[i]}</td><td>${pr.predVals[i]}</td><td>${err}</td></tr>`;
            copyLines.push(`${pr.tilt}\t${pr.bgLabels[i]}\t${pr.actualVals[i]}\t${pr.predVals[i]}\t${err}`);
          }
        }
        compHTML += '</tbody></table>';
        compHTML += `<textarea class="copy-area" readonly>${copyLines.join('\n')}</textarea>`;
        compHTML += '</div>';

        resultsDiv.innerHTML = `<div class="result-grid">${paramsHTML}${compHTML}</div>`;

        // Draw chart
        chartsDiv.innerHTML = '<div class="chart-card"><h4>Predicted vs Actual PU</h4><canvas id="vsmCanvas" width="520" height="420"></canvas></div>';
        const canvas = document.getElementById('vsmCanvas');
        if (canvas) drawVsmChart(canvas, dataPoints, fit);

      } catch (error) {
        resultsDiv.textContent = 'No results yet.';
        chartsDiv.textContent = 'No figures yet.';
        msg.textContent = error.message;
      }
    }

    vsmAddRows(VSM_DEFAULT_ROWS);
    document.getElementById('vsmGridBody').addEventListener('paste', vsmHandlePaste);
    document.getElementById('vsmAddRows').addEventListener('click', () => vsmAddRows(10));
    document.getElementById('vsmClearGrid').addEventListener('click', vsmClearGrid);
    document.getElementById('vsmRun').addEventListener('click', runVectorSumModel);
  </script>
</body>
</html>
