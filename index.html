<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sigmoid PU Calculator</title>
  <style>
    :root { font-family: Arial, sans-serif; }
    body { margin: 24px; color: #1f2937; background: #f8fafc; }
    h1 { margin-bottom: 8px; }
    .card { background: white; border-radius: 10px; padding: 16px; box-shadow: 0 1px 3px rgba(0,0,0,.1); margin-bottom: 16px; }
    .small { font-size: 12px; color: #6b7280; }
    .controls { margin: 10px 0; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    button { padding: 8px 10px; border: none; border-radius: 6px; cursor: pointer; color: #fff; background: #2563eb; }
    button:hover { background: #1d4ed8; }
    .btn-secondary { background: #4b5563; }
    .btn-secondary:hover { background: #374151; }
    .error { color: #b91c1c; font-weight: 600; min-height: 20px; }

    .grid-wrap { overflow: auto; border: 1px solid #d1d5db; border-radius: 8px; max-height: 430px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #d1d5db; padding: 0; }
    .input-grid th { background: #f3f4f6; position: sticky; top: 0; z-index: 2; }
    .input-grid input {
      width: 100%; border: none; padding: 7px; box-sizing: border-box;
      font-size: 13px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
    }
    .input-grid input:focus { outline: 2px solid #93c5fd; outline-offset: -2px; }
    .group-pd { background: #e0f2fe !important; }
    .group-dp { background: #dcfce7 !important; }
    .group-gauss { background: #fef3c7 !important; }
    .group-vsm { background: #ede9fe !important; }
    .vsm-fixed { text-align: center; color: #6b7280; font-variant-numeric: tabular-nums; padding: 7px !important; font-size: 13px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .vsm-col-header { border: none; background: transparent; font-weight: 600; text-align: center; width: 100%; min-width: 90px; padding: 7px; box-sizing: border-box; font-size: 13px; }

    .result-table th, .result-table td { padding: 8px; text-align: right; }
    .result-table th:first-child, .result-table td:first-child { text-align: left; }
    .result-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(420px, 1fr)); gap: 12px; }
    .result-block { border: 1px solid #d1d5db; border-radius: 8px; overflow: hidden; }
    .result-block h4 { margin: 0; padding: 8px 10px; background: #f3f4f6; }
    .copy-area { width: 100%; min-height: 90px; box-sizing: border-box; border: none; border-top: 1px solid #d1d5db; padding: 8px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; }

    /* Tab navigation */
    .tab-bar { display: flex; gap: 0; margin-bottom: 16px; }
    .tab-btn { padding: 10px 20px; border: 1px solid #d1d5db; border-bottom: none; border-radius: 8px 8px 0 0; cursor: pointer; background: #e5e7eb; color: #374151; font-weight: 600; font-size: 14px; }
    .tab-btn.active { background: #fff; color: #2563eb; border-bottom: 2px solid #fff; margin-bottom: -1px; z-index: 1; }
    .tab-btn:hover:not(.active) { background: #f3f4f6; }
    .tab-panel { display: none; }
    .tab-panel.active { display: block; }

    /* Chart grid */
    .chart-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(460px, 1fr)); gap: 16px; }
    .chart-card { border: 1px solid #d1d5db; border-radius: 8px; overflow: hidden; background: #fff; }
    .chart-card h4 { margin: 0; padding: 8px 12px; background: #f3f4f6; font-size: 14px; }
    .chart-card canvas { display: block; width: 100%; }
  </style>
</head>
<body>
  <h1>Pre-VR Upright PU Calculator</h1>

  <div class="tab-bar">
    <button class="tab-btn active" data-tab="pu">PU Calculator</button>
    <button class="tab-btn" data-tab="gauss">Gaussian FMS Analysis</button>
    <button class="tab-btn" data-tab="vsm">Vector Sum Model</button>
  </div>

  <!-- ===== PU Calculator Tab ===== -->
  <div id="tab-pu" class="tab-panel active">
  <p class="small">Paste all 16 columns directly from Excel. Left block is p-d (x + 7 columns), right block is d-p (x + 7 columns).</p>

  <div class="card">
    <div class="controls">
      <button id="addRows" class="btn-secondary" type="button">Add 10 Rows</button>
      <button id="clearGrid" class="btn-secondary" type="button">Clear Grid</button>
      <button id="runCalc" type="button">Calculate PU</button>
    </div>

    <div class="grid-wrap">
      <table class="input-grid">
        <thead>
          <tr>
            <th class="group-pd"><input data-header="0" value="p-d_x"></th>
            <th class="group-pd"><input data-header="1" value="p-d_grey"></th>
            <th class="group-pd"><input data-header="2" value="p-d_room_0"></th>
            <th class="group-pd"><input data-header="3" value="p-d_room_60"></th>
            <th class="group-pd"><input data-header="4" value="p-d_room_120"></th>
            <th class="group-pd"><input data-header="5" value="p-d_room_180"></th>
            <th class="group-pd"><input data-header="6" value="p-d_room_240"></th>
            <th class="group-pd"><input data-header="7" value="p-d_room_300"></th>
            <th class="group-dp"><input data-header="8" value="d-p_x"></th>
            <th class="group-dp"><input data-header="9" value="d-p_grey"></th>
            <th class="group-dp"><input data-header="10" value="d-p_room_0"></th>
            <th class="group-dp"><input data-header="11" value="d-p_room_60"></th>
            <th class="group-dp"><input data-header="12" value="d-p_room_120"></th>
            <th class="group-dp"><input data-header="13" value="d-p_room_180"></th>
            <th class="group-dp"><input data-header="14" value="d-p_room_240"></th>
            <th class="group-dp"><input data-header="15" value="d-p_room_300"></th>
          </tr>
        </thead>
        <tbody id="gridBody"></tbody>
      </table>
    </div>

    <p id="message" class="error"></p>
  </div>

  <div class="card">
    <h3>Results (copy-friendly format)</h3>
    <div id="results">No results yet.</div>
    <p class="small">PU formulas used: <strong>b(PU) = (|b(p-d)| + |b(d-p)|)/2</strong>, <strong>x0(PU) = ((x0(p-d) + x0(d-p))/2) - 180</strong>.</p>
  </div>
  </div><!-- end tab-pu -->

  <!-- ===== Gaussian FMS Analysis Tab ===== -->
  <div id="tab-gauss" class="tab-panel">
    <p class="small">Enter each participant's x0 value (per background) and FMS score. One row per participant. The app will fit a 3-parameter Gaussian for each background.</p>

    <div class="card">
      <div class="controls">
        <button id="gaussAddRows" class="btn-secondary" type="button">Add 10 Rows</button>
        <button id="gaussClearGrid" class="btn-secondary" type="button">Clear Grid</button>
        <button id="gaussRun" type="button">Run Gaussian Fit</button>
      </div>

      <div class="grid-wrap">
        <table class="input-grid">
          <thead>
            <tr>
              <th class="group-gauss">FMS</th>
              <th class="group-gauss">x0 grey</th>
              <th class="group-gauss">x0 room_0</th>
              <th class="group-gauss">x0 room_60</th>
              <th class="group-gauss">x0 room_120</th>
              <th class="group-gauss">x0 room_180</th>
              <th class="group-gauss">x0 room_240</th>
              <th class="group-gauss">x0 room_300</th>
            </tr>
          </thead>
          <tbody id="gaussGridBody"></tbody>
        </table>
      </div>

      <p id="gaussMessage" class="error"></p>
    </div>

    <div class="card">
      <h3>Gaussian Fit Results</h3>
      <div id="gaussResults">No results yet.</div>
    </div>

    <div class="card">
      <h3>Figures</h3>
      <div id="gaussCharts" class="chart-grid">No figures yet.</div>
    </div>
  </div><!-- end tab-gauss -->

  <!-- ===== Vector Sum Model Tab ===== -->
  <div id="tab-vsm" class="tab-panel">
    <p class="small">Paste PU x0 values for each condition. Tilt and Vis are fixed (12 rows). Each condition column is fit independently: v (visual weight) and b (body weight) with g&nbsp;=&nbsp;1 fixed. Paste only the PU columns (not Tilt/Vis).</p>

    <div class="card">
      <div class="controls">
        <button id="vsmAddCol" class="btn-secondary" type="button">Add Column</button>
        <button id="vsmRemoveCol" class="btn-secondary" type="button">Remove Column</button>
        <button id="vsmClearGrid" class="btn-secondary" type="button">Clear Values</button>
        <button id="vsmRun" type="button">Fit Vector Sum Model</button>
      </div>

      <div class="grid-wrap">
        <table class="input-grid" id="vsmTable">
          <thead><tr id="vsmHead"></tr></thead>
          <tbody id="vsmGridBody"></tbody>
        </table>
      </div>

      <p id="vsmMessage" class="error"></p>
    </div>

    <div class="card">
      <h3>Vector Sum Model Results</h3>
      <div id="vsmResults">No results yet.</div>
    </div>

    <div class="card">
      <h3>Predicted vs Actual</h3>
      <div id="vsmCharts" class="chart-grid">No figures yet.</div>
    </div>
  </div><!-- end tab-vsm -->

  <script>
    const TOTAL_COLUMNS = 16;
    const DEFAULT_ROWS = 45;

    function createRow(rowIndex) {
      const tr = document.createElement('tr');
      for (let c = 0; c < TOTAL_COLUMNS; c += 1) {
        const td = document.createElement('td');
        const input = document.createElement('input');
        input.type = 'text';
        input.dataset.row = String(rowIndex);
        input.dataset.col = String(c);
        td.appendChild(input);
        tr.appendChild(td);
      }
      return tr;
    }

    function addRows(count) {
      const body = document.getElementById('gridBody');
      const start = body.children.length;
      for (let i = 0; i < count; i += 1) body.appendChild(createRow(start + i));
    }

    function clearGrid() {
      document.querySelectorAll('#gridBody input').forEach((input) => { input.value = ''; });
    }

    function parseNumber(value) {
      const cleaned = value.trim();
      if (!cleaned) return null;
      const n = Number(cleaned);
      return Number.isFinite(n) ? n : null;
    }

    function headerNames() {
      const headers = [];
      document.querySelectorAll('thead input[data-header]').forEach((input, idx) => {
        headers.push(input.value.trim() || `col_${idx + 1}`);
      });
      return headers;
    }

    function collectData() {
      const headers = headerNames();
      const rows = [...document.querySelectorAll('#gridBody tr')];

      const pdX = [];
      const dpX = [];
      const pdSeries = Array.from({ length: 7 }, () => []);
      const dpSeries = Array.from({ length: 7 }, () => []);

      rows.forEach((row) => {
        const cells = [...row.querySelectorAll('input')];
        if (cells.length < TOTAL_COLUMNS) return;

        const xPd = parseNumber(cells[0].value);
        if (xPd !== null) {
          pdX.push(xPd);
          for (let i = 0; i < 7; i += 1) pdSeries[i].push(parseNumber(cells[i + 1].value));
        }

        const xDp = parseNumber(cells[8].value);
        if (xDp !== null) {
          dpX.push(xDp);
          for (let i = 0; i < 7; i += 1) dpSeries[i].push(parseNumber(cells[i + 9].value));
        }
      });

      if (pdX.length === 0 && dpX.length === 0) throw new Error('No valid x values found in the p-d or d-p x columns.');

      return { headers, pdX, pdSeries, dpX, dpSeries };
    }

    function handleGridPaste(event) {
      const target = event.target;
      if (!(target instanceof HTMLInputElement) || !target.closest('#gridBody')) return;

      const pasted = event.clipboardData?.getData('text');
      if (!pasted) return;
      event.preventDefault();

      const rowStart = Number(target.dataset.row);
      const colStart = Number(target.dataset.col);
      const lines = pasted.replace(/\r/g, '').split('\n').filter((line) => line.length > 0);
      const matrix = lines.map((line) => line.split('\t'));

      const neededRows = rowStart + matrix.length;
      const currentRows = document.querySelectorAll('#gridBody tr').length;
      if (neededRows > currentRows) addRows(neededRows - currentRows + 5);

      matrix.forEach((cells, rOffset) => {
        const r = rowStart + rOffset;
        cells.forEach((value, cOffset) => {
          const c = colStart + cOffset;
          if (c >= TOTAL_COLUMNS) return;
          const cell = document.querySelector(`#gridBody input[data-row="${r}"][data-col="${c}"]`);
          if (cell) cell.value = value.trim();
        });
      });
    }

    function sigmoid(x, b, x0) {
      const z = -(x - x0) / b;
      if (z > 60) return 0;
      if (z < -60) return 1;
      return 1 / (1 + Math.exp(z));
    }

    function sse(data, b, x0) {
      let err = 0;
      for (const [x, y] of data) {
        const d = sigmoid(x, b, x0) - y;
        err += d * d;
      }
      return err;
    }

    function rSquared(data, b, x0) {
      const meanY = data.reduce((sum, [, y]) => sum + y, 0) / data.length;
      let ssRes = 0;
      let ssTot = 0;
      for (const [x, y] of data) {
        const pred = sigmoid(x, b, x0);
        ssRes += (y - pred) ** 2;
        ssTot += (y - meanY) ** 2;
      }
      if (ssTot === 0) return NaN;
      return 1 - (ssRes / ssTot);
    }

    function fitColumn(data, direction) {
      const xs = data.map(([x]) => x);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);

      let bestErr = Infinity;
      let bestB = direction === 'dp' ? 1 : -1;
      let bestX0 = 0;

      const bMin = direction === 'dp' ? 0.05 : -200;
      const bMax = direction === 'dp' ? 200 : 0.95;
      const x0Min = Math.floor(minX - 100);
      const x0Max = Math.ceil(maxX + 100);

      for (let b = bMin; b <= bMax; b += 0.5) {
        if (Math.abs(b) < 1e-9) continue;
        if (direction === 'pd' && !(b < 1)) continue;
        if (direction === 'dp' && !(b > 0)) continue;

        for (let x0 = x0Min; x0 <= x0Max; x0 += 1) {
          const err = sse(data, b, x0);
          if (err < bestErr) {
            bestErr = err;
            bestB = b;
            bestX0 = x0;
          }
        }
      }

      let stepB = 5;
      let stepX0 = 5;
      while (stepB > 1e-4) {
        let improved = false;
        for (const db of [0, -stepB, stepB]) {
          for (const dx of [0, -stepX0, stepX0]) {
            const candB = bestB + db;
            if (Math.abs(candB) < 1e-9) continue;
            if (direction === 'pd' && !(candB < 1)) continue;
            if (direction === 'dp' && !(candB > 0)) continue;
            const candX0 = bestX0 + dx;
            const err = sse(data, candB, candX0);
            if (err < bestErr) {
              bestErr = err;
              bestB = candB;
              bestX0 = candX0;
              improved = true;
            }
          }
        }
        if (!improved) {
          stepB /= 2;
          stepX0 /= 2;
        }
      }

      return { b: bestB, x0: bestX0, r2: rSquared(data, bestB, bestX0), sse: bestErr, n: data.length };
    }

    function buildCopyTable(title, labels, rowsByMetric) {
      const header = [''].concat(labels).join('\t');
      const lines = [title, header];
      rowsByMetric.forEach((metricRow) => {
        lines.push([metricRow.label].concat(metricRow.values).join('\t'));
      });
      return lines.join('\n');
    }

    function renderBlock(title, labels, rowsByMetric) {
      const thead = `<tr><th></th>${labels.map((l) => `<th>${l}</th>`).join('')}</tr>`;
      const tbody = rowsByMetric
        .map((metricRow) => `<tr><td>${metricRow.label}</td>${metricRow.values.map((v) => `<td>${v}</td>`).join('')}</tr>`)
        .join('');
      const copyText = buildCopyTable(title, labels, rowsByMetric)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

      return `
        <div class="result-block">
          <h4>${title}</h4>
          <table class="result-table">
            <thead>${thead}</thead>
            <tbody>${tbody}</tbody>
          </table>
          <textarea class="copy-area" readonly>${copyText}</textarea>
        </div>
      `;
    }

    function renderResults(rows) {
      const labels = rows.map((row) => row.name);

      const pdBlock = renderBlock('Pre-VR Upright p-d', labels, [
        { label: 'b(preVR)', values: rows.map((row) => row.pdB) },
        { label: 'x0(preVR)', values: rows.map((row) => row.pdX0) },
        { label: 'Rsq', values: rows.map((row) => row.pdR2) },
      ]);

      const dpBlock = renderBlock('Pre-VR Upright d-p', labels, [
        { label: 'b(preVR)', values: rows.map((row) => row.dpB) },
        { label: 'x0(preVR)', values: rows.map((row) => row.dpX0) },
        { label: 'Rsq', values: rows.map((row) => row.dpR2) },
      ]);

      const puBlock = renderBlock('Pre-VR Upright PU', labels, [
        { label: 'b(preVR)', values: rows.map((row) => row.puB) },
        { label: 'x0(preVR)', values: rows.map((row) => row.puX0) },
      ]);

      return `<div class="result-grid">${pdBlock}${dpBlock}${puBlock}</div>`;
    }

    function toFmt(v) {
      return Number.isFinite(v) ? v.toFixed(4) : 'NaN';
    }

    function runCalculation() {
      const msg = document.getElementById('message');
      const resultsDiv = document.getElementById('results');
      msg.textContent = '';

      try {
        const { headers, pdX, pdSeries, dpX, dpSeries } = collectData();
        const rows = [];

        for (let i = 0; i < 7; i += 1) {
          const pdPoints = [];
          for (let r = 0; r < pdX.length; r += 1) {
            const y = pdSeries[i][r];
            if (y !== null) pdPoints.push([pdX[r], y]);
          }

          const dpPoints = [];
          for (let r = 0; r < dpX.length; r += 1) {
            const y = dpSeries[i][r];
            if (y !== null) dpPoints.push([dpX[r], y]);
          }

          const pdFit = pdPoints.length >= 3 ? fitColumn(pdPoints, 'pd') : null;
          const dpFit = dpPoints.length >= 3 ? fitColumn(dpPoints, 'dp') : null;

          const puB = (pdFit && dpFit) ? (Math.abs(pdFit.b) + Math.abs(dpFit.b)) / 2 : NaN;
          const puX0 = (pdFit && dpFit) ? ((pdFit.x0 + dpFit.x0) / 2) - 180 : NaN;

          rows.push({
            name: headers[i + 1].replace(/^p-d_/, ''),
            pdB: toFmt(pdFit?.b),
            pdX0: toFmt(pdFit?.x0),
            pdR2: toFmt(pdFit?.r2),
            dpB: toFmt(dpFit?.b),
            dpX0: toFmt(dpFit?.x0),
            dpR2: toFmt(dpFit?.r2),
            puB: toFmt(puB),
            puX0: toFmt(puX0),
          });
        }

        resultsDiv.innerHTML = renderResults(rows);
      } catch (error) {
        resultsDiv.textContent = 'No results yet.';
        msg.textContent = error.message;
      }
    }

    addRows(DEFAULT_ROWS);
    document.getElementById('gridBody').addEventListener('paste', handleGridPaste);
    document.getElementById('addRows').addEventListener('click', () => addRows(10));
    document.getElementById('clearGrid').addEventListener('click', clearGrid);
    document.getElementById('runCalc').addEventListener('click', runCalculation);

    /* ========== Tab switching ========== */
    document.querySelectorAll('.tab-btn').forEach((btn) => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach((b) => b.classList.remove('active'));
        document.querySelectorAll('.tab-panel').forEach((p) => p.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
      });
    });

    /* ========== Gaussian FMS Analysis ========== */
    const GAUSS_COLS = 8; // FMS + 7 backgrounds
    const GAUSS_DEFAULT_ROWS = 30;
    const GAUSS_BG_NAMES = ['grey', 'room_0', 'room_60', 'room_120', 'room_180', 'room_240', 'room_300'];

    function gaussCreateRow(rowIndex) {
      const tr = document.createElement('tr');
      for (let c = 0; c < GAUSS_COLS; c++) {
        const td = document.createElement('td');
        const input = document.createElement('input');
        input.type = 'text';
        input.dataset.row = String(rowIndex);
        input.dataset.col = String(c);
        td.appendChild(input);
        tr.appendChild(td);
      }
      return tr;
    }

    function gaussAddRows(count) {
      const body = document.getElementById('gaussGridBody');
      const start = body.children.length;
      for (let i = 0; i < count; i++) body.appendChild(gaussCreateRow(start + i));
    }

    function gaussClearGrid() {
      document.querySelectorAll('#gaussGridBody input').forEach((input) => { input.value = ''; });
    }

    function gaussHandlePaste(event) {
      const target = event.target;
      if (!(target instanceof HTMLInputElement) || !target.closest('#gaussGridBody')) return;
      const pasted = event.clipboardData?.getData('text');
      if (!pasted) return;
      event.preventDefault();

      const rowStart = Number(target.dataset.row);
      const colStart = Number(target.dataset.col);
      const lines = pasted.replace(/\r/g, '').split('\n').filter((l) => l.length > 0);
      const matrix = lines.map((l) => l.split('\t'));

      const neededRows = rowStart + matrix.length;
      const currentRows = document.querySelectorAll('#gaussGridBody tr').length;
      if (neededRows > currentRows) gaussAddRows(neededRows - currentRows + 5);

      matrix.forEach((cells, rOff) => {
        cells.forEach((val, cOff) => {
          const c = colStart + cOff;
          if (c >= GAUSS_COLS) return;
          const cell = document.querySelector(`#gaussGridBody input[data-row="${rowStart + rOff}"][data-col="${c}"]`);
          if (cell) cell.value = val.trim();
        });
      });
    }

    /* Collect Gaussian data: returns { fms: number[], x0PerBg: number[][] } */
    function gaussCollectData() {
      const rows = [...document.querySelectorAll('#gaussGridBody tr')];
      const fms = [];
      const x0PerBg = Array.from({ length: 7 }, () => []);

      rows.forEach((row) => {
        const cells = [...row.querySelectorAll('input')];
        if (cells.length < GAUSS_COLS) return;
        const fmsVal = parseNumber(cells[0].value);
        if (fmsVal === null) return;

        // Need at least one x0 in the row
        let hasX0 = false;
        const x0Vals = [];
        for (let i = 0; i < 7; i++) {
          const v = parseNumber(cells[i + 1].value);
          x0Vals.push(v);
          if (v !== null) hasX0 = true;
        }
        if (!hasX0) return;

        fms.push(fmsVal);
        for (let i = 0; i < 7; i++) x0PerBg[i].push(x0Vals[i]);
      });

      if (fms.length < 3) throw new Error('Need at least 3 participants with valid FMS and x0 data.');
      return { fms, x0PerBg };
    }

    /* 3-parameter Gaussian: y = a * exp(-((x - mu)^2) / (2 * sigma^2)) */
    function gaussian(x, a, mu, sigma) {
      return a * Math.exp(-((x - mu) ** 2) / (2 * sigma * sigma));
    }

    function gaussSSE(pairs, a, mu, sigma) {
      let err = 0;
      for (const [x, y] of pairs) {
        const d = gaussian(x, a, mu, sigma) - y;
        err += d * d;
      }
      return err;
    }

    function gaussRSquared(pairs, a, mu, sigma) {
      const meanY = pairs.reduce((s, [, y]) => s + y, 0) / pairs.length;
      let ssRes = 0, ssTot = 0;
      for (const [x, y] of pairs) {
        ssRes += (y - gaussian(x, a, mu, sigma)) ** 2;
        ssTot += (y - meanY) ** 2;
      }
      return ssTot === 0 ? NaN : 1 - ssRes / ssTot;
    }

    function fitGaussian(pairs) {
      // pairs: [[x0, fms], ...]
      const xs = pairs.map(([x]) => x);
      const ys = pairs.map(([, y]) => y);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const maxY = Math.max(...ys);
      const meanX = xs.reduce((a, b) => a + b, 0) / xs.length;

      let bestErr = Infinity;
      let bestA = maxY, bestMu = meanX, bestSig = (maxX - minX) / 4;

      // Coarse grid search
      for (let a = maxY * 0.2; a <= maxY * 1.5; a += maxY * 0.1 || 0.5) {
        for (let mu = minX; mu <= maxX; mu += (maxX - minX) / 20 || 1) {
          for (let sig = (maxX - minX) * 0.05; sig <= (maxX - minX) * 1.5; sig += (maxX - minX) * 0.1 || 1) {
            if (sig < 0.01) continue;
            const err = gaussSSE(pairs, a, mu, sig);
            if (err < bestErr) {
              bestErr = err;
              bestA = a;
              bestMu = mu;
              bestSig = sig;
            }
          }
        }
      }

      // Refinement via hill-climbing
      let stepA = maxY * 0.1 || 1;
      let stepMu = (maxX - minX) * 0.1 || 1;
      let stepSig = (maxX - minX) * 0.1 || 1;

      while (stepA > 1e-4 && stepMu > 1e-4 && stepSig > 1e-4) {
        let improved = false;
        for (const da of [0, -stepA, stepA]) {
          for (const dm of [0, -stepMu, stepMu]) {
            for (const ds of [0, -stepSig, stepSig]) {
              const cA = bestA + da;
              const cMu = bestMu + dm;
              const cSig = bestSig + ds;
              if (cA < 0 || cSig < 0.01) continue;
              const err = gaussSSE(pairs, cA, cMu, cSig);
              if (err < bestErr) {
                bestErr = err;
                bestA = cA;
                bestMu = cMu;
                bestSig = cSig;
                improved = true;
              }
            }
          }
        }
        if (!improved) {
          stepA /= 2;
          stepMu /= 2;
          stepSig /= 2;
        }
      }

      return { a: bestA, mu: bestMu, sigma: bestSig, r2: gaussRSquared(pairs, bestA, bestMu, bestSig), sse: bestErr, n: pairs.length };
    }

    /* Draw a chart on a canvas element */
    function drawGaussChart(canvas, pairs, fit, title) {
      const ctx = canvas.getContext('2d');
      const W = canvas.width;
      const H = canvas.height;
      const pad = { top: 30, right: 20, bottom: 50, left: 60 };
      const plotW = W - pad.left - pad.right;
      const plotH = H - pad.top - pad.bottom;

      ctx.clearRect(0, 0, W, H);

      // Data ranges
      const xs = pairs.map(([x]) => x);
      const ys = pairs.map(([, y]) => y);
      const xMin = Math.min(...xs) - Math.abs(Math.min(...xs)) * 0.1 - 5;
      const xMax = Math.max(...xs) + Math.abs(Math.max(...xs)) * 0.1 + 5;

      // Compute Gaussian curve to find actual y-range
      const curvePts = [];
      for (let i = 0; i <= 200; i++) {
        const x = xMin + (xMax - xMin) * (i / 200);
        curvePts.push([x, gaussian(x, fit.a, fit.mu, fit.sigma)]);
      }
      const allY = ys.concat(curvePts.map(([, y]) => y));
      const yMin = Math.min(0, Math.min(...allY) - 1);
      const yMax = Math.max(...allY) * 1.15;

      function toCanvasX(x) { return pad.left + ((x - xMin) / (xMax - xMin)) * plotW; }
      function toCanvasY(y) { return pad.top + plotH - ((y - yMin) / (yMax - yMin)) * plotH; }

      // Background
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, W, H);

      // Grid lines
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;
      const yTicks = 6;
      for (let i = 0; i <= yTicks; i++) {
        const y = yMin + (yMax - yMin) * (i / yTicks);
        const cy = toCanvasY(y);
        ctx.beginPath(); ctx.moveTo(pad.left, cy); ctx.lineTo(W - pad.right, cy); ctx.stroke();
      }

      // Axes
      ctx.strokeStyle = '#374151';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(pad.left, pad.top);
      ctx.lineTo(pad.left, pad.top + plotH);
      ctx.lineTo(W - pad.right, pad.top + plotH);
      ctx.stroke();

      // Axis labels
      ctx.fillStyle = '#374151';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';

      // X-axis ticks
      const xTicks = 6;
      for (let i = 0; i <= xTicks; i++) {
        const x = xMin + (xMax - xMin) * (i / xTicks);
        const cx = toCanvasX(x);
        ctx.beginPath(); ctx.moveTo(cx, pad.top + plotH); ctx.lineTo(cx, pad.top + plotH + 5); ctx.stroke();
        ctx.fillText(x.toFixed(1), cx, pad.top + plotH + 18);
      }

      // Y-axis ticks
      ctx.textAlign = 'right';
      for (let i = 0; i <= yTicks; i++) {
        const y = yMin + (yMax - yMin) * (i / yTicks);
        const cy = toCanvasY(y);
        ctx.fillText(y.toFixed(1), pad.left - 8, cy + 4);
      }

      // Axis titles
      ctx.save();
      ctx.font = '13px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('x0', pad.left + plotW / 2, H - 5);
      ctx.save();
      ctx.translate(15, pad.top + plotH / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('FMS', 0, 0);
      ctx.restore();
      ctx.restore();

      // Gaussian curve
      ctx.strokeStyle = '#dc2626';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      curvePts.forEach(([x, y], i) => {
        const cx = toCanvasX(x);
        const cy = toCanvasY(y);
        if (i === 0) ctx.moveTo(cx, cy);
        else ctx.lineTo(cx, cy);
      });
      ctx.stroke();

      // Data points
      ctx.fillStyle = '#2563eb';
      pairs.forEach(([x, y]) => {
        const cx = toCanvasX(x);
        const cy = toCanvasY(y);
        ctx.beginPath();
        ctx.arc(cx, cy, 5, 0, Math.PI * 2);
        ctx.fill();
      });

      // Title
      ctx.fillStyle = '#111827';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(title, W / 2, 18);

      // Fit info
      ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, monospace';
      ctx.fillStyle = '#6b7280';
      ctx.textAlign = 'left';
      ctx.fillText(`a=${fit.a.toFixed(2)}  mu=${fit.mu.toFixed(2)}  sigma=${fit.sigma.toFixed(2)}  R²=${fit.r2.toFixed(4)}`, pad.left + 5, pad.top + 15);
    }

    function runGaussianAnalysis() {
      const msg = document.getElementById('gaussMessage');
      const resultsDiv = document.getElementById('gaussResults');
      const chartsDiv = document.getElementById('gaussCharts');
      msg.textContent = '';

      try {
        const { fms, x0PerBg } = gaussCollectData();
        const fits = [];
        let resultsHTML = '';
        let chartsHTML = '';

        for (let i = 0; i < 7; i++) {
          const pairs = [];
          for (let j = 0; j < fms.length; j++) {
            if (x0PerBg[i][j] !== null) pairs.push([x0PerBg[i][j], fms[j]]);
          }

          if (pairs.length < 3) {
            fits.push(null);
            continue;
          }

          const fit = fitGaussian(pairs);
          fits.push({ ...fit, pairs });
          chartsHTML += `<div class="chart-card"><h4>${GAUSS_BG_NAMES[i]}</h4><canvas id="gaussCanvas_${i}" width="520" height="380"></canvas></div>`;
        }

        // Results table
        const labels = GAUSS_BG_NAMES.filter((_, i) => fits[i] !== null);
        const validFits = fits.filter((f) => f !== null);
        resultsHTML = renderBlock('Gaussian Fit Parameters', labels, [
          { label: 'a', values: validFits.map((f) => f.a.toFixed(4)) },
          { label: 'mu', values: validFits.map((f) => f.mu.toFixed(4)) },
          { label: 'sigma', values: validFits.map((f) => f.sigma.toFixed(4)) },
          { label: 'R²', values: validFits.map((f) => f.r2.toFixed(4)) },
          { label: 'n', values: validFits.map((f) => String(f.n)) },
        ]);

        resultsDiv.innerHTML = resultsHTML;
        chartsDiv.innerHTML = chartsHTML || 'No backgrounds with enough data.';

        // Draw charts after DOM update
        for (let i = 0; i < 7; i++) {
          if (!fits[i]) continue;
          const canvas = document.getElementById(`gaussCanvas_${i}`);
          if (canvas) drawGaussChart(canvas, fits[i].pairs, fits[i], GAUSS_BG_NAMES[i]);
        }
      } catch (error) {
        resultsDiv.textContent = 'No results yet.';
        chartsDiv.textContent = 'No figures yet.';
        msg.textContent = error.message;
      }
    }

    gaussAddRows(GAUSS_DEFAULT_ROWS);
    document.getElementById('gaussGridBody').addEventListener('paste', gaussHandlePaste);
    document.getElementById('gaussAddRows').addEventListener('click', () => gaussAddRows(10));
    document.getElementById('gaussClearGrid').addEventListener('click', gaussClearGrid);
    document.getElementById('gaussRun').addEventListener('click', runGaussianAnalysis);

    /* ========== Vector Sum Model ========== */
    const VSM_FIXED_ROWS = [
      { tilt: 0, vis: 0 }, { tilt: 0, vis: 60 }, { tilt: 0, vis: 120 },
      { tilt: 0, vis: 180 }, { tilt: 0, vis: 240 }, { tilt: 0, vis: 300 },
      { tilt: -90, vis: 0 }, { tilt: -90, vis: 60 }, { tilt: -90, vis: 120 },
      { tilt: -90, vis: 180 }, { tilt: -90, vis: 240 }, { tilt: -90, vis: 300 },
    ];
    const VSM_VIS_ANGLES = [0, 60, 120, 180, 240, 300];
    const DEG2RAD = Math.PI / 180;
    const RAD2DEG = 180 / Math.PI;

    let vsmConditions = ['Pre VR RSD', 'noSTIM', 'STIM'];

    function vsmBuildGrid() {
      const headRow = document.getElementById('vsmHead');
      const tbody = document.getElementById('vsmGridBody');

      // Save existing values
      const oldVals = {};
      tbody.querySelectorAll('input[data-row][data-col]').forEach((inp) => {
        oldVals[`${inp.dataset.row}_${inp.dataset.col}`] = inp.value;
      });

      // Header
      headRow.innerHTML = '<th class="group-vsm">Tilt</th><th class="group-vsm">Vis</th>';
      vsmConditions.forEach((name, ci) => {
        const th = document.createElement('th');
        th.className = 'group-vsm';
        const inp = document.createElement('input');
        inp.type = 'text';
        inp.value = name;
        inp.className = 'vsm-col-header';
        inp.addEventListener('change', () => { vsmConditions[ci] = inp.value; });
        th.appendChild(inp);
        headRow.appendChild(th);
      });

      // Body
      tbody.innerHTML = '';
      VSM_FIXED_ROWS.forEach((fr, ri) => {
        const tr = document.createElement('tr');
        const tdTilt = document.createElement('td');
        tdTilt.textContent = String(fr.tilt);
        tdTilt.className = 'vsm-fixed';
        tr.appendChild(tdTilt);
        const tdVis = document.createElement('td');
        tdVis.textContent = String(fr.vis);
        tdVis.className = 'vsm-fixed';
        tr.appendChild(tdVis);

        vsmConditions.forEach((_, ci) => {
          const td = document.createElement('td');
          const inp = document.createElement('input');
          inp.type = 'text';
          inp.dataset.row = String(ri);
          inp.dataset.col = String(ci);
          const key = `${ri}_${ci}`;
          if (oldVals[key]) inp.value = oldVals[key];
          td.appendChild(inp);
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
    }

    function vsmAddCol() {
      vsmConditions.push(`Condition ${vsmConditions.length + 1}`);
      vsmBuildGrid();
    }

    function vsmRemoveCol() {
      if (vsmConditions.length <= 1) return;
      vsmConditions.pop();
      vsmBuildGrid();
    }

    function vsmClearGrid() {
      document.querySelectorAll('#vsmGridBody input').forEach((inp) => { inp.value = ''; });
    }

    function vsmHandlePaste(event) {
      const target = event.target;
      if (!(target instanceof HTMLInputElement) || !target.closest('#vsmGridBody')) return;
      const pasted = event.clipboardData?.getData('text');
      if (!pasted) return;
      event.preventDefault();

      const rowStart = Number(target.dataset.row);
      const colStart = Number(target.dataset.col);
      const lines = pasted.replace(/\r/g, '').split('\n').filter((l) => l.length > 0);
      const matrix = lines.map((l) => l.split('\t'));

      matrix.forEach((cells, rOff) => {
        cells.forEach((val, cOff) => {
          const r = rowStart + rOff;
          const c = colStart + cOff;
          if (r >= VSM_FIXED_ROWS.length || c >= vsmConditions.length) return;
          const inp = document.querySelector(`#vsmGridBody input[data-row="${r}"][data-col="${c}"]`);
          if (inp) inp.value = val.trim();
        });
      });
    }

    /* Predict PU: 2-parameter model (v = visual weight, b = body weight, g = 1 fixed) */
    function vsmPredict(tiltDeg, visDeg, v, b) {
      const g = 1;
      const tilt = tiltDeg * DEG2RAD;
      const vis = visDeg * DEG2RAD;
      const x = v * Math.sin(vis) + g * Math.sin(tilt);
      const y = b + v * Math.cos(vis) + g * Math.cos(tilt);
      return Math.atan2(x, y) * RAD2DEG;
    }

    function angleDiff(a, b) {
      let d = a - b;
      while (d > 180) d -= 360;
      while (d < -180) d += 360;
      return d;
    }

    function vsmSSE(dataPoints, v, b) {
      let err = 0;
      for (const dp of dataPoints) {
        const pred = vsmPredict(dp.tilt, dp.vis, v, b);
        const d = angleDiff(pred, dp.actualPU);
        err += d * d;
      }
      return err;
    }

    /* Fit v, b using coarse grid + gradient descent + hill climbing */
    function fitVSM(dataPoints) {
      let bestErr = Infinity, bestV = 0, bestB = 1;

      // Coarse grid
      for (let v = -2; v <= 2; v += 0.05) {
        for (let b = -2; b <= 8; b += 0.1) {
          const err = vsmSSE(dataPoints, v, b);
          if (err < bestErr) { bestErr = err; bestV = v; bestB = b; }
        }
      }

      // Gradient descent with adaptive step
      let lr = 0.0001;
      for (let iter = 0; iter < 50000; iter++) {
        const h = 1e-7;
        const f0 = vsmSSE(dataPoints, bestV, bestB);
        const gv = (vsmSSE(dataPoints, bestV + h, bestB) - f0) / h;
        const gb = (vsmSSE(dataPoints, bestV, bestB + h) - f0) / h;
        const nV = bestV - lr * gv;
        const nB = bestB - lr * gb;
        const nErr = vsmSSE(dataPoints, nV, nB);
        if (nErr < bestErr) { bestErr = nErr; bestV = nV; bestB = nB; lr *= 1.05; }
        else { lr *= 0.5; }
        if (lr < 1e-15) break;
      }

      // Final hill-climbing polish
      let step = 0.001;
      while (step > 1e-9) {
        let improved = false;
        for (const dv of [0, -step, step]) {
          for (const db of [0, -step, step]) {
            if (dv === 0 && db === 0) continue;
            const err = vsmSSE(dataPoints, bestV + dv, bestB + db);
            if (err < bestErr) { bestErr = err; bestV += dv; bestB += db; improved = true; }
          }
        }
        if (!improved) step /= 2;
      }

      const mean = dataPoints.reduce((s, dp) => s + dp.actualPU, 0) / dataPoints.length;
      let ssTot = 0;
      for (const dp of dataPoints) ssTot += angleDiff(dp.actualPU, mean) ** 2;
      const r2 = ssTot === 0 ? NaN : 1 - bestErr / ssTot;

      return { v: bestV, b: bestB, r2, sse: bestErr, n: dataPoints.length };
    }

    /* Draw predicted vs actual scatter plot */
    function drawVsmChart(canvas, dataPoints, fit, title) {
      const ctx = canvas.getContext('2d');
      const W = canvas.width;
      const H = canvas.height;
      const pad = { top: 30, right: 20, bottom: 50, left: 60 };
      const plotW = W - pad.left - pad.right;
      const plotH = H - pad.top - pad.bottom;

      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, W, H);

      const actuals = dataPoints.map((dp) => dp.actualPU);
      const predicteds = dataPoints.map((dp) => vsmPredict(dp.tilt, dp.vis, fit.v, fit.b));
      const all = actuals.concat(predicteds);
      const dMin = Math.min(...all) - 5;
      const dMax = Math.max(...all) + 5;

      function toX(val) { return pad.left + ((val - dMin) / (dMax - dMin)) * plotW; }
      function toY(val) { return pad.top + plotH - ((val - dMin) / (dMax - dMin)) * plotH; }

      // Grid lines
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;
      const ticks = 6;
      for (let i = 0; i <= ticks; i++) {
        const val = dMin + (dMax - dMin) * (i / ticks);
        ctx.beginPath(); ctx.moveTo(pad.left, toY(val)); ctx.lineTo(W - pad.right, toY(val)); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(toX(val), pad.top); ctx.lineTo(toX(val), pad.top + plotH); ctx.stroke();
      }

      // Axes
      ctx.strokeStyle = '#374151';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(pad.left, pad.top);
      ctx.lineTo(pad.left, pad.top + plotH);
      ctx.lineTo(W - pad.right, pad.top + plotH);
      ctx.stroke();

      // Identity line
      ctx.strokeStyle = '#9ca3af';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(toX(dMin), toY(dMin));
      ctx.lineTo(toX(dMax), toY(dMax));
      ctx.stroke();
      ctx.setLineDash([]);

      // Axis labels
      ctx.fillStyle = '#374151';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      for (let i = 0; i <= ticks; i++) {
        const val = dMin + (dMax - dMin) * (i / ticks);
        ctx.fillText(val.toFixed(1), toX(val), pad.top + plotH + 18);
      }
      ctx.textAlign = 'right';
      for (let i = 0; i <= ticks; i++) {
        const val = dMin + (dMax - dMin) * (i / ticks);
        ctx.fillText(val.toFixed(1), pad.left - 8, toY(val) + 4);
      }

      // Axis titles
      ctx.font = '13px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Actual PU (°)', pad.left + plotW / 2, H - 5);
      ctx.save();
      ctx.translate(15, pad.top + plotH / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Predicted PU (°)', 0, 0);
      ctx.restore();

      // Color by vis
      const visColors = ['#2563eb', '#dc2626', '#059669', '#d97706', '#7c3aed', '#db2777'];

      // Points: circle for tilt=0, triangle for tilt=-90
      dataPoints.forEach((dp, i) => {
        const cx = toX(dp.actualPU);
        const cy = toY(predicteds[i]);
        ctx.fillStyle = visColors[dp.visIdx];
        if (dp.tilt === 0) {
          ctx.beginPath(); ctx.arc(cx, cy, 5, 0, Math.PI * 2); ctx.fill();
        } else {
          ctx.beginPath(); ctx.moveTo(cx, cy - 6); ctx.lineTo(cx - 5, cy + 4); ctx.lineTo(cx + 5, cy + 4); ctx.closePath(); ctx.fill();
        }
      });

      // Title
      ctx.fillStyle = '#111827';
      ctx.font = 'bold 13px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(title, W / 2, 18);

      // Fit info
      ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, monospace';
      ctx.fillStyle = '#6b7280';
      ctx.textAlign = 'left';
      ctx.fillText(`v=${fit.v.toFixed(4)}  b=${fit.b.toFixed(4)}  R²=${fit.r2.toFixed(4)}`, pad.left + 5, pad.top + 15);

      // Legend
      const legendY = pad.top + 28;
      VSM_VIS_ANGLES.forEach((angle, i) => {
        ctx.fillStyle = visColors[i];
        ctx.beginPath(); ctx.arc(pad.left + 12, legendY + i * 15, 4, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#374151'; ctx.font = '10px Arial'; ctx.textAlign = 'left';
        ctx.fillText(`vis ${angle}°`, pad.left + 22, legendY + i * 15 + 3);
      });
      const shapeY = legendY + 6 * 15 + 5;
      ctx.fillStyle = '#374151';
      ctx.beginPath(); ctx.arc(pad.left + 12, shapeY, 4, 0, Math.PI * 2); ctx.fill();
      ctx.font = '10px Arial'; ctx.fillText('= tilt 0°', pad.left + 22, shapeY + 3);
      ctx.beginPath(); ctx.moveTo(pad.left + 12, shapeY + 15 - 5); ctx.lineTo(pad.left + 7, shapeY + 15 + 3); ctx.lineTo(pad.left + 17, shapeY + 15 + 3); ctx.closePath(); ctx.fill();
      ctx.fillText('= tilt -90°', pad.left + 22, shapeY + 18);
    }

    function runVectorSumModel() {
      const msg = document.getElementById('vsmMessage');
      const resultsDiv = document.getElementById('vsmResults');
      const chartsDiv = document.getElementById('vsmCharts');
      msg.textContent = '';

      try {
        const condResults = [];

        for (let ci = 0; ci < vsmConditions.length; ci++) {
          const dataPoints = [];
          for (let ri = 0; ri < VSM_FIXED_ROWS.length; ri++) {
            const inp = document.querySelector(`#vsmGridBody input[data-row="${ri}"][data-col="${ci}"]`);
            if (!inp) continue;
            const val = parseNumber(inp.value);
            if (val === null) continue;
            const visIdx = ri < 6 ? ri : ri - 6;
            dataPoints.push({ tilt: VSM_FIXED_ROWS[ri].tilt, vis: VSM_FIXED_ROWS[ri].vis, visIdx, actualPU: val });
          }
          if (dataPoints.length < 2) continue;

          const fit = fitVSM(dataPoints);
          condResults.push({ name: vsmConditions[ci], fit, dataPoints });
        }

        if (condResults.length === 0) throw new Error('No conditions with enough data (need at least 2 values per condition).');

        // === v/b summary table (matches user's expected format) ===
        const condNames = condResults.map((cr) => cr.name + ' Vector Sum');
        const summaryHTML = renderBlock('Vector Sum Model', condNames, [
          { label: 'v', values: condResults.map((cr) => cr.fit.v.toFixed(4)) },
          { label: 'b', values: condResults.map((cr) => cr.fit.b.toFixed(4)) },
          { label: 'R²', values: condResults.map((cr) => cr.fit.r2.toFixed(4)) },
          { label: 'SSE', values: condResults.map((cr) => cr.fit.sse.toFixed(4)) },
          { label: 'n', values: condResults.map((cr) => String(cr.fit.n)) },
        ]);

        // === Per-condition predicted vs actual tables ===
        let compHTML = '';
        for (const cr of condResults) {
          let tbl = `<div class="result-block"><h4>${cr.name} Vector Sum</h4><table class="result-table"><thead><tr><th>Tilt</th><th>Vis</th><th>Actual</th><th>Predicted</th><th>Error</th></tr></thead><tbody>`;
          const copyLines = [`${cr.name} Vector Sum`, 'Tilt\tVis\tActual\tPredicted\tError'];
          for (const dp of cr.dataPoints) {
            const pred = vsmPredict(dp.tilt, dp.vis, cr.fit.v, cr.fit.b);
            const err = angleDiff(pred, dp.actualPU);
            tbl += `<tr><td>${dp.tilt}</td><td>${dp.vis}</td><td>${dp.actualPU.toFixed(4)}</td><td>${pred.toFixed(4)}</td><td>${err.toFixed(4)}</td></tr>`;
            copyLines.push(`${dp.tilt}\t${dp.vis}\t${dp.actualPU.toFixed(4)}\t${pred.toFixed(4)}\t${err.toFixed(4)}`);
          }
          tbl += '</tbody></table>';
          tbl += `<textarea class="copy-area" readonly>${copyLines.join('\n')}</textarea></div>`;
          compHTML += tbl;
        }

        resultsDiv.innerHTML = `<div class="result-grid">${summaryHTML}${compHTML}</div>`;

        // === Charts ===
        let chartsHTML = '';
        condResults.forEach((cr, idx) => {
          chartsHTML += `<div class="chart-card"><h4>${cr.name} Vector Sum</h4><canvas id="vsmCanvas_${idx}" width="520" height="420"></canvas></div>`;
        });
        chartsDiv.innerHTML = chartsHTML || 'No figures yet.';

        condResults.forEach((cr, idx) => {
          const canvas = document.getElementById(`vsmCanvas_${idx}`);
          if (canvas) drawVsmChart(canvas, cr.dataPoints, cr.fit, cr.name + ' Vector Sum');
        });

      } catch (error) {
        resultsDiv.textContent = 'No results yet.';
        chartsDiv.textContent = 'No figures yet.';
        msg.textContent = error.message;
      }
    }

    vsmBuildGrid();
    document.getElementById('vsmGridBody').addEventListener('paste', vsmHandlePaste);
    document.getElementById('vsmAddCol').addEventListener('click', vsmAddCol);
    document.getElementById('vsmRemoveCol').addEventListener('click', vsmRemoveCol);
    document.getElementById('vsmClearGrid').addEventListener('click', vsmClearGrid);
    document.getElementById('vsmRun').addEventListener('click', runVectorSumModel);
  </script>
</body>
</html>
